<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Session - Impostor Game</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="card game-card">
            <div class="game-header">
                <div class="top-left-info">
                    <div class="score-badge" id="scoreBadge">
                        <span class="score-label">üéÖ Your Points</span>
                        <span class="score-number" id="myScore">0</span>
                    </div>
                </div>
                <div class="top-right-info">
                    <div class="turn-order" id="turnOrderDisplay">
                        <span>üéÅ Turn: <strong id="turnOrderNumber">-</strong> / <strong id="totalPlayers">-</strong></span>
                    </div>
                </div>
            </div>

            <div id="impostorBadge" class="impostor-badge" style="display: none;">
                üïµÔ∏è‚Äç‚ôÇÔ∏è YOU ARE THE GRINCH üïµÔ∏è‚Äç‚ôÇÔ∏è
            </div>

            <div class="word-display">
                <p class="word-label">Your word:</p>
                <div class="word" id="wordDisplay">---</div>
            </div>

            <div id="speakingSection" style="text-align: center; margin: 20px 0;">
                <!-- Button ONLY appears for the person whose turn it is -->
                <button id="speakNowBtn" class="btn btn-primary" style="display: none; width: 100%; max-width: 350px; padding: 25px; font-size: 1.4em; background: #27ae60; border: 4px solid #2ecc71; border-radius: 50px; box-shadow: 0 8px 15px rgba(0,0,0,0.2); color: white; font-weight: 800; cursor: pointer;">
                    üé§ SPEAK NOW! <br>
                    <small style="font-size: 0.6em; font-weight: 400;">(Click here when you are finished)</small>
                </button>
                
                <!-- Simple status for everyone else -->
                <div id="othersSpeakingStatus" style="display: none; font-size: 1.2em; color: #c0392b; font-weight: 800; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 10px; border: 2px dashed #c0392b;">
                    üì¢ <span id="otherSpeakerName">...</span> is speaking...
                </div>
            </div>

            <div id="votingSection" class="voting-section" style="display: none;">
                <h3>‚ùÑÔ∏è Find the Grinch! ‚ùÑÔ∏è</h3>
                <div id="votingLockerMessage" class="voting-locked-message" style="display: none;">
                    üîí Voting is currently locked by the host. Discussion time!
                </div>
                <div id="playerVoteList" class="player-vote-list"></div>
                <div id="voteStatus" class="vote-status"></div>
            </div>

            <div id="roundResults" class="round-results" style="display: none;">
                <h3>Round Results</h3>
                <div id="resultsContent"></div>
            </div>

            <div id="hostControls" class="host-controls" style="display: none;">
                <button id="toggleVotingBtn" class="btn btn-secondary">üîì Unlock Voting</button>
                <button id="endRoundBtn" class="btn btn-secondary">End Round</button>
                <button id="newRoundBtn" class="btn btn-primary">New Round</button>
                <button id="endGameBtn" class="btn btn-danger">End Game</button>
            </div>

            <div id="guestMessage" class="guest-message" style="display: none;">
                <p>Waiting for host to start next round...</p>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="client.js"></script>
    <script>
        // Get room code and host status from URL
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room');
        const isHost = urlParams.get('host') === 'true';

        // Initialize socket
        const socket = io();
        window.gameSocket = socket;

        // Get player name from sessionStorage or URL
        let playerName = sessionStorage.getItem('playerName');
        if (!playerName) {
            // If no sessionStorage (incognito/new tab), try to get from URL
            if (isHost) {
                playerName = 'Host';
            } else {
                const urlName = urlParams.get('name');
                playerName = urlName || 'Player';
            }
            // Store for future use
            if (playerName) {
                sessionStorage.setItem('playerName', playerName);
            }
        }

        // Game state
        let currentPlayers = [];
        let myTurnOrder = null;
        let hasVoted = false;
        let votingLocked = true;
        let currentSpeakerTurn = 1;
        let lastSpeakerName = 'Someone';

        function updateSpeakerUI() {
            const speakNowBtn = document.getElementById('speakNowBtn');
            const othersSpeakingStatus = document.getElementById('othersSpeakingStatus');
            const otherSpeakerName = document.getElementById('otherSpeakerName');
            
            if (!speakNowBtn || !othersSpeakingStatus) return;

            // Ensure both are treated as numbers for comparison
            const isMyTurn = myTurnOrder !== null && parseInt(currentSpeakerTurn) === parseInt(myTurnOrder);
            
            console.log('Updating Speaker UI. Current turn:', currentSpeakerTurn, 'My turn:', myTurnOrder, 'Is my turn?', isMyTurn);

            if (isMyTurn) {
                speakNowBtn.style.display = 'block';
                othersSpeakingStatus.style.display = 'none';
            } else {
                speakNowBtn.style.display = 'none';
                othersSpeakingStatus.style.display = 'block';
                otherSpeakerName.textContent = lastSpeakerName;
            }
        }

        // Rejoin room to receive word if game has started
        function rejoinRoom() {
            if (roomCode && playerName) {
                // Small delay to ensure socket is fully ready
                setTimeout(() => {
                    socket.emit('joinRoom', { roomCode, name: playerName });
                }, 100);
            }
        }

        // Rejoin immediately if socket is already connected, otherwise wait for connect
        if (socket.connected) {
            rejoinRoom();
        } else {
            socket.on('connect', () => {
                rejoinRoom();
            });
        }

        // Also handle joinError
        socket.on('joinError', (data) => {
            console.error('Join error:', data.message);
            // If game already started error, that's okay - we'll get the word on rejoin
            if (data.message !== 'Game has already started') {
                // Show error in a div instead of alert
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = data.message;
                errorDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px 20px; border-radius: 6px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
                document.body.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 5000);
            }
        });

        // Show/hide host controls
        if (isHost) {
            document.getElementById('hostControls').style.display = 'block';
            document.getElementById('guestMessage').style.display = 'none';
        } else {
            document.getElementById('hostControls').style.display = 'none';
            document.getElementById('guestMessage').style.display = 'none';
        }

        // Display word and impostor status
        socket.on('gameStarted', (data) => {
            console.log('Game started with data:', data);
            displayWord(data.word, data.isImpostor);
            document.getElementById('roundResults').style.display = 'none';
            document.getElementById('votingSection').style.display = 'block';
            hasVoted = false;
            votingLocked = true; // Default locked
            updateVotingUI();
            
            // Show end round button for host
            if (isHost) {
                document.getElementById('endRoundBtn').style.display = 'inline-block';
                document.getElementById('toggleVotingBtn').style.display = 'inline-block';
                document.getElementById('toggleVotingBtn').textContent = 'üîì Unlock Voting';
            }
            
            if (data.players) {
                currentPlayers = data.players;
                
                // Get turnOrder - prioritize direct data, then players array
                if (data.turnOrder !== null && data.turnOrder !== undefined) {
                    myTurnOrder = parseInt(data.turnOrder);
                    console.log('Turn order received directly:', myTurnOrder);
                } else {
                    // Try to get from players array
                    const myPlayer = data.players.find(p => p.name === playerName);
                    if (myPlayer && myPlayer.turnOrder !== null && myPlayer.turnOrder !== undefined) {
                        myTurnOrder = parseInt(myPlayer.turnOrder);
                        console.log('Turn order from players array:', myTurnOrder);
                    } else {
                        console.log('No turn order found for player:', playerName);
                    }
                }
                
                updateTurnOrderDisplay();
                updateScores();
                setupVoting();
                updateSpeakerUI();
            }
        });

        socket.on('newRoundStarted', (data) => {
            console.log('New round started with data:', data);
            displayWord(data.word, data.isImpostor);
            document.getElementById('guestMessage').style.display = 'none';
            document.getElementById('roundResults').style.display = 'none';
            document.getElementById('votingSection').style.display = 'block';
            hasVoted = false;
            votingLocked = true; // Default locked
            updateVotingUI();
            
            // Show end round button for host
            if (isHost) {
                document.getElementById('endRoundBtn').style.display = 'inline-block';
                document.getElementById('toggleVotingBtn').style.display = 'inline-block';
                document.getElementById('toggleVotingBtn').textContent = 'üîì Unlock Voting';
            }
            
            if (data.players) {
                currentPlayers = data.players;
                
                // Get turnOrder - prioritize direct data, then players array
                if (data.turnOrder !== null && data.turnOrder !== undefined) {
                    myTurnOrder = parseInt(data.turnOrder);
                    console.log('Turn order received directly:', myTurnOrder);
                } else {
                    // Try to get from players array
                    const myPlayer = data.players.find(p => p.name === playerName);
                    if (myPlayer && myPlayer.turnOrder !== null && myPlayer.turnOrder !== undefined) {
                        myTurnOrder = parseInt(myPlayer.turnOrder);
                        console.log('Turn order from players array:', myTurnOrder);
                    } else {
                        console.log('No turn order found for player:', playerName);
                    }
                }
                
                updateTurnOrderDisplay();
                updateScores();
                setupVoting();
                updateSpeakerUI();
            }
        });

        socket.on('speakerUpdate', (data) => {
            currentSpeakerTurn = data.currentSpeaker;
            lastSpeakerName = data.speakerName;
            updateSpeakerUI();
        });

        document.getElementById('speakNowBtn').addEventListener('click', () => {
            socket.emit('nextSpeaker', { roomCode });
        });

        function displayWord(word, isImpostor) {
            document.getElementById('wordDisplay').textContent = word;
            
            if (isImpostor) {
                document.getElementById('impostorBadge').style.display = 'block';
                document.body.classList.add('impostor-mode');
            } else {
                document.getElementById('impostorBadge').style.display = 'none';
                document.body.classList.remove('impostor-mode');
            }
        }

        function updateTurnOrderDisplay() {
            const turnOrderDisplay = document.getElementById('turnOrderDisplay');
            const turnOrderNumber = document.getElementById('turnOrderNumber');
            const totalPlayers = document.getElementById('totalPlayers');
            
            // Try to find myself in currentPlayers to get turnOrder if not already set
            if (!myTurnOrder && currentPlayers && currentPlayers.length > 0) {
                const myPlayer = currentPlayers.find(p => p.name === playerName);
                if (myPlayer && myPlayer.turnOrder) {
                    myTurnOrder = myPlayer.turnOrder;
                }
            }
            
            // Show the display
            turnOrderDisplay.style.display = 'block';
            
            if (myTurnOrder && currentPlayers && currentPlayers.length > 0) {
                turnOrderNumber.textContent = myTurnOrder;
                totalPlayers.textContent = currentPlayers.length;
            } else {
                turnOrderNumber.textContent = '-';
                totalPlayers.textContent = (currentPlayers && currentPlayers.length > 0) ? currentPlayers.length : '-';
            }
        }

        function updateScores() {
            const scoreBadge = document.getElementById('scoreBadge');
            const myScoreElement = document.getElementById('myScore');
            
            // Always show score badge
            scoreBadge.style.display = 'block';
            
            if (currentPlayers && currentPlayers.length > 0) {
                // Find current player's score
                const myPlayer = currentPlayers.find(p => p.name === playerName);
                if (myPlayer) {
                    myScoreElement.textContent = myPlayer.score || 0;
                } else {
                    myScoreElement.textContent = '0';
                }
            } else {
                myScoreElement.textContent = '0';
            }
        }

        function setupVoting() {
            const votingSection = document.getElementById('votingSection');
            const playerVoteList = document.getElementById('playerVoteList');
            
            console.log('Setting up voting. Current players:', currentPlayers, 'Player name:', playerName);
            
            if (!currentPlayers || currentPlayers.length < 2) {
                console.log('Not enough players for voting');
                votingSection.style.display = 'none';
                return;
            }

            votingSection.style.display = 'block';
            playerVoteList.innerHTML = '';
            // Don't reset hasVoted here, it's reset in gameStarted/newRoundStarted

            // Get other players (not yourself)
            const otherPlayers = currentPlayers.filter(p => p.name !== playerName);
            console.log('Other players to vote for:', otherPlayers);
            
            if (otherPlayers.length === 0) {
                console.log('No other players to vote for');
                votingSection.style.display = 'none';
                return;
            }
            
            otherPlayers.forEach(player => {
                const voteButton = document.createElement('button');
                voteButton.className = 'btn btn-vote';
                voteButton.id = `vote-btn-${player.name}`;
                voteButton.textContent = player.name;
                
                // Set initial state based on votingLocked and hasVoted
                if (votingLocked || hasVoted) {
                    voteButton.disabled = true;
                }

                voteButton.onclick = () => {
                    console.log('Vote clicked for:', player.name);
                    if (!hasVoted && !votingLocked) {
                        // Disable all vote buttons
                        const allVoteButtons = document.querySelectorAll('.btn-vote');
                        allVoteButtons.forEach(btn => {
                            btn.disabled = true;
                        });
                        
                        // Mark selected button
                        voteButton.classList.add('voted');
                        voteButton.textContent = `${player.name} ‚úì (Your Vote)`;
                        
                        socket.emit('voteImpostor', {
                            roomCode: roomCode,
                            votedPlayerName: player.name
                        });
                        hasVoted = true;
                        console.log('Vote sent for:', player.name);
                    }
                };
                playerVoteList.appendChild(voteButton);
            });
            
            updateVotingUI();
            console.log('Voting buttons created:', otherPlayers.length);
        }

        function updateVotingUI() {
            const lockerMessage = document.getElementById('votingLockerMessage');
            const allVoteButtons = document.querySelectorAll('.btn-vote');
            
            if (votingLocked) {
                lockerMessage.style.display = 'block';
                allVoteButtons.forEach(btn => {
                    btn.disabled = true;
                });
            } else {
                lockerMessage.style.display = 'none';
                if (!hasVoted) {
                    allVoteButtons.forEach(btn => {
                        btn.disabled = false;
                    });
                }
            }
        }

        // Handle voting status updates
        socket.on('votingStatusUpdate', (data) => {
            votingLocked = data.locked;
            updateVotingUI();
            
            if (isHost) {
                const toggleBtn = document.getElementById('toggleVotingBtn');
                toggleBtn.textContent = votingLocked ? 'üîì Unlock Voting' : 'üîí Lock Voting';
            }

            const voteStatus = document.getElementById('voteStatus');
            voteStatus.innerHTML = `<strong>Votes: ${data.totalVotes}/${data.totalPlayers}</strong><br><small>(Everyone must vote to see results)</small>`;
        });

        // Handle vote updates
        socket.on('voteUpdate', (data) => {
            const voteStatus = document.getElementById('voteStatus');
            voteStatus.innerHTML = `<strong>Votes: ${data.totalVotes}/${data.totalPlayers}</strong>`;
            
            // Update vote buttons to show who voted for whom (if visible)
            if (data.votes) {
                Object.keys(data.votes).forEach(voterName => {
                    const votedPlayerName = data.votes[voterName];
                    // We can't show individual votes to prevent cheating, but we show the count
                });
            }
        });

        // Handle round ended
        socket.on('roundEnded', (data) => {
            document.getElementById('votingSection').style.display = 'none';
            document.getElementById('roundResults').style.display = 'block';
            
            // Hide end round and toggle buttons, show new round button
            if (isHost) {
                document.getElementById('endRoundBtn').style.display = 'none';
                document.getElementById('toggleVotingBtn').style.display = 'none';
                document.getElementById('hostControls').style.display = 'block';
            }
            
            const resultsContent = document.getElementById('resultsContent');
            let html = '';
            
            if (data.impostorFound) {
                html += '<p class="result-success">‚úÖ Impostor Found!</p>';
                html += '<p>Non-impostors gain 1 point. Impostor gains 0 points.</p>';
            } else {
                html += '<p class="result-fail">‚ùå Impostor Not Found!</p>';
                html += '<p>Impostor gains 1 point. Others gain 0 points.</p>';
            }
            
            html += '<h4>Vote Results:</h4><ul>';
            // Show all players, even if they got 0 votes
            data.players.forEach(player => {
                const voteCount = data.voteCounts[player.name] || 0;
                html += `<li>${player.name}: ${voteCount} vote(s)</li>`;
            });
            html += '</ul>';
            
            html += '<h4>Impostor(s) were:</h4><ul>';
            data.impostorNames.forEach(name => {
                html += `<li><strong>${name}</strong></li>`;
            });
            html += '</ul>';
            
            html += '<h4>Updated Scores:</h4><ul>';
            // Sort by score
            const sortedPlayers = [...data.players].sort((a, b) => (b.score || 0) - (a.score || 0));
            sortedPlayers.forEach(player => {
                const isMe = player.name === playerName;
                html += `<li class="${isMe ? 'my-score-result' : ''}">${player.name}${isMe ? ' (You)' : ''}: <strong>${player.score || 0}</strong> point(s)</li>`;
            });
            html += '</ul>';
            
            resultsContent.innerHTML = html;
            
            // Update local player list and scores
            currentPlayers = data.players;
            updateScores();
        });

        // Handle vote errors
        socket.on('voteError', (data) => {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = data.message;
            errorDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px 20px; border-radius: 6px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 3000);
        });

        // Host controls (host only)
        if (isHost) {
            // Initially hide end round button (only show during active round)
            document.getElementById('endRoundBtn').style.display = 'none';
            document.getElementById('toggleVotingBtn').style.display = 'none';

            document.getElementById('toggleVotingBtn').addEventListener('click', () => {
                socket.emit('toggleVoting', { roomCode });
            });
            
            document.getElementById('endRoundBtn').addEventListener('click', () => {
                const confirmDiv = document.createElement('div');
                confirmDiv.className = 'modal';
                confirmDiv.innerHTML = `
                    <div class="modal-content">
                        <h2>End Round?</h2>
                        <p>Are you sure you want to end the current round? All players will vote now.</p>
                        <div class="modal-buttons">
                            <button id="confirmEndRound" class="btn btn-primary">Yes, End Round</button>
                            <button id="cancelEndRound" class="btn btn-secondary">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(confirmDiv);
                
                document.getElementById('confirmEndRound').addEventListener('click', () => {
                    socket.emit('endRound', { roomCode });
                    confirmDiv.remove();
                });
                
                document.getElementById('cancelEndRound').addEventListener('click', () => {
                    confirmDiv.remove();
                });
            });

            document.getElementById('newRoundBtn').addEventListener('click', () => {
                socket.emit('newRound', { roomCode });
            });

            document.getElementById('endGameBtn').addEventListener('click', () => {
                const confirmDiv = document.createElement('div');
                confirmDiv.className = 'modal';
                confirmDiv.innerHTML = `
                    <div class="modal-content">
                        <h2>End Game?</h2>
                        <p>Are you sure you want to end the game?</p>
                        <div class="modal-buttons">
                            <button id="confirmEndGame" class="btn btn-danger">Yes, End Game</button>
                            <button id="cancelEndGame" class="btn btn-secondary">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(confirmDiv);
                
                document.getElementById('confirmEndGame').addEventListener('click', () => {
                    socket.emit('endGame', { roomCode });
                    confirmDiv.remove();
                });
                
                document.getElementById('cancelEndGame').addEventListener('click', () => {
                    confirmDiv.remove();
                });
            });
        }

        // Handle game ended
        socket.on('gameEnded', (data) => {
            // Show message in div
            const endDiv = document.createElement('div');
            endDiv.className = 'game-ended-message';
            endDiv.innerHTML = `
                <div class="modal">
                    <div class="modal-content">
                        <h2>Game Ended!</h2>
                        <h3>Final Scores:</h3>
                        <div class="final-scores-list" style="margin: 20px 0; text-align: left;">
                            ${data && data.players ? 
                                data.players.sort((a, b) => (b.score || 0) - (a.score || 0))
                                    .map((p, i) => `<p style="padding: 8px; border-bottom: 1px solid #eee;">${i + 1}. <strong>${p.name}</strong>: ${p.score || 0} pts</p>`).join('') 
                                : '<p>No score data available</p>'}
                        </div>
                        <button id="returnHomeBtn" class="btn btn-primary" style="width: 100%;">Return to Home</button>
                    </div>
                </div>
            `;
            document.body.appendChild(endDiv);
            
            document.getElementById('returnHomeBtn').onclick = () => {
                socket.disconnect();
                window.location.href = 'index.html';
            };

            // Auto-redirect after 10 seconds if they don't click
            setTimeout(() => {
                if (window.location.pathname.includes('game.html')) {
                    socket.disconnect();
                    window.location.href = 'index.html';
                }
            }, 10000);
        });

        // Handle host left
        socket.on('hostLeft', () => {
            const leftDiv = document.createElement('div');
            leftDiv.className = 'error-message';
            leftDiv.textContent = 'Host left the game. Returning to home...';
            leftDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px 20px; border-radius: 6px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            document.body.appendChild(leftDiv);
            setTimeout(() => {
                socket.disconnect();
                window.location.href = 'index.html';
            }, 3000);
        });

        // Handle errors
        socket.on('gameError', (data) => {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = data.message;
            errorDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px 20px; border-radius: 6px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        });
    </script>
</body>
</html>

